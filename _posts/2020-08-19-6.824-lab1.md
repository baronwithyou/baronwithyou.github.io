---
date: 2020-08-19 20:58:10
layout: post
title: "6.824: Distributed Systems lab1"
subtitle:
description: åˆ†å¸ƒå¼ç³»ç»Ÿlab1è§£å†³æ–¹æ¡ˆ
image:
optimized_image:
category: 'distributed systems'
tags:
- distributed systems
author:
paginate: false
---
## æ¦‚è¿°
æœ‰å…³lab1çš„è¦æ±‚ä»¥åŠåˆå§‹ä»£ç å¯ä»¥åœ¨ [https://pdos.csail.mit.edu/6.824/labs/lab-mr.html](https://pdos.csail.mit.edu/6.824/labs/lab-mr.html) ä¸­è·å–ã€‚

## é—®é¢˜ä¸æ€è·¯

é¦–å…ˆéœ€è¦ç†è§£`mapreduce`æ¨¡å‹ä»¥åŠ`master`å’Œ`worker`ä¹‹é—´çš„å…³ç³»ï¼Œè¿™äº›ä¿¡æ¯åœ¨[paper](http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf)ä¸­éƒ½æœ‰ã€‚

ä»å›¾ä¸­å¯ä»¥çœ‹å‡º`master`è´Ÿè´£å°†`map`å’Œ`reduce`çš„ä»»åŠ¡åˆ†é…ç»™`worker`ï¼Œ`worker`å¯¹æŒ‡å®šçš„æ–‡ä»¶è¿›è¡Œæ“ä½œåæŒ‰ç…§æ ¼å¼å†™å…¥åˆ°è¾“å‡ºæ–‡ä»¶ä¸­ã€‚

### 1. ä»ä½•å…¥æ‰‹

1. æŸ¥çœ‹lab1çš„è¦æ±‚å’Œæç¤ºï¼Œæ˜ç™½ä½œä¸šæœ€ç»ˆéœ€è¦è¾¾æˆä»€ä¹ˆç›®çš„ã€‚
2. å°è¯•ç†è§£å¹¶ä¸”è¿è¡Œä»£ç `mrsequential.go`ï¼ŒçŸ¥é“è¾“å‡ºä»€ä¹ˆå½¢å¼çš„æ•°æ®ã€‚
3. åˆ©ç”¨ç»™å‡ºçš„ç¬¬ä¸€æ¡æç¤ºï¼šä¿®æ”¹`mr/master`ä»£ç ï¼Œè®©å…¶å‘é€ä¸€æ¡RPCè¯·æ±‚ç»™masterã€‚

### 2. ä»»åŠ¡çŠ¶æ€
ä¸ºäº†è®°å½•`map`å’Œ`reduce`çš„è¿è¡Œé˜¶æ®µï¼Œéœ€è¦ç»™ä»»åŠ¡åˆ†é…çŠ¶æ€ä½ã€‚
```golang
const (
	TaskInit = iota  // åˆå§‹å€¼
	TaskRunning      // ä»»åŠ¡è¿è¡Œä¸­
	TaskDone         // ä»»åŠ¡å·²å®Œæˆ
)
```

### 3. æµç¨‹ç®¡ç†
éœ€è¦åœ¨æ‰€æœ‰çš„`map`ä»»åŠ¡å®Œæˆä¹‹åæ‰èƒ½è¿›è¡Œ`reduce`ä»»åŠ¡åˆ†é…ã€‚æ‰€ä»¥`map`ä»»åŠ¡è¿˜æœªå®Œæˆï¼Œä½¿ç”¨`Empty`å‚æ•°é€šçŸ¥ç»™`worker`ã€‚
```golang
for _, v := range m.mapTask {
    if v != TaskDone {
        reply.Empty = true
        return nil
    }
}
```

## å®Œæ•´ç¤ºä¾‹

ç”±äºè¯¥labè¿˜æ˜¯ä¸€ä¸ªä½œä¸šï¼Œå¹¶ä¸”æœ‰äººå‘¼åå¤§å®¶ä¸è¦å°†ä»£ç å¼€æºæ”¾åœ¨githubä¸Šï¼Œè¿™é‡Œæˆ‘åªè´´å‡ºéƒ¨åˆ†å…³é”®ä»£ç ä½œä¸ºå‚è€ƒã€‚
è‹¥æœ‰ä¸æ˜ç™½çš„åœ°æ–¹ï¼Œå¯ä»¥è”ç³»æˆ‘è¿›è¡Œè§£ç­”ï¼Œé‚®ç®±ï¼šbaronwithyou@gmail.comã€‚

### rpc.go
```golang

const (
	Map    = "map"
	Reduce = "reduce"
)

type AssignArgs struct {}

type AssignReply struct {
	Empty    bool
	Filename string
	NReduce  int
	Index    int
	Type     string
	Finished bool
}

type CommitArgs struct {
	Filename string
	ID       int
	Type     string
}

type CommitReply struct {}
```

### master.go
```golang
const (
	TaskInit = iota
	TaskRunning
	TaskDone
)

type Master struct {
	// Your definitions here.
	files      []string
	nReduce    int
	mapTask    []int
	reduceTask []int
	lock       sync.Mutex
	timeout    time.Duration
	done       bool
}

// Assign dispatch task to specific worker
func (m *Master) Assign(args *AssignArgs, reply *AssignReply) error {
	m.lock.Lock()
	defer m.lock.Unlock()

	ctx, _ := context.WithTimeout(context.Background(), m.timeout)

	if m.assignMapTask(ctx, args, reply) {
		return nil
	}

	for _, v := range m.mapTask {
		if v != TaskDone {
			reply.Empty = true
			return nil
		}
	}

	if m.assignReduceTask(ctx, args, reply) {
		return nil
	}

	for _, v := range m.reduceTask {
		if v != TaskDone {
			reply.Empty = true
			return nil
		}
	}
	m.done = true
	reply.Finished = true

	return nil
}

func (m *Master) assignMapTask(ctx context.Context, args *AssignArgs, reply *AssignReply) bool {
	for id, v := range m.mapTask {
		if v == TaskRunning || v == TaskDone {
			continue
		}

		//fmt.Printf("A worker is requiring a map task\n")

		reply.Filename = m.files[id]
		reply.Index = id
		reply.NReduce = m.nReduce
		reply.Type = Map

		m.mapTask[id] = TaskRunning

		go func(c context.Context) {
			select {
			case <-ctx.Done():
				m.lock.Lock()
				defer m.lock.Unlock()

				if m.mapTask[id] == TaskRunning {
					m.mapTask[id] = TaskInit
					log.Printf("%v map task timeout\n", m.files[id])
				}
			}
		}(ctx)

		return true
	}

	return false
}

func (m *Master) assignReduceTask(ctx context.Context, args *AssignArgs, reply *AssignReply) bool {
	for id, v := range m.reduceTask {
		if v == TaskRunning || v == TaskDone {
			continue
		}

		//fmt.Printf("A worker has require a reduce task\n")
		m.reduceTask[id] = TaskRunning

		reply.Index = id
		reply.NReduce = m.nReduce
		reply.Type = Reduce

		go func(c context.Context) {
			select {
			case <-ctx.Done():
				m.lock.Lock()
				defer m.lock.Unlock()

				if m.reduceTask[id] == TaskRunning {
					m.reduceTask[id] = TaskInit
					log.Printf("%v reduce task timeout\n", id)
				}
			}
		}(ctx)

		return true
	}

	return false
}

// Commit ...
func (m *Master) Commit(args *CommitArgs, reply *CommitReply) error {
	m.lock.Lock()
	defer m.lock.Unlock()

	switch args.Type {
	case Map:
		//fmt.Printf("%v has been mapped\n", m.files[args.ID])
		m.mapTask[args.ID] = TaskDone
	case Reduce:
		//fmt.Printf("mr-out-%v has been reduced\n", args.ID)
		m.reduceTask[args.ID] = TaskDone
	}

	return nil
}

```

### worker.go
```golang
// for sorting by key.
type ByKey []KeyValue

// for sorting by key.
func (a ByKey) Len() int           { return len(a) }
func (a ByKey) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool { return a[i].Key < a[j].Key }

func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) {

	for {
		ok, res := GetMapTask()
		if !ok || res.Finished {
			break
		}

		// Wait if master is waiting for all files to be mapped
		if res.Empty {
			continue
		}

		args := &CommitArgs{}
		args.Type = res.Type
		args.ID = res.Index

		switch res.Type {
		case Map:
			if err := mapping(mapf, res.Filename, res.NReduce, res.Index); err != nil {
				log.Fatal(err)
			}
		case Reduce:
			if err := reducing(reducef, res.NReduce, res.Index); err != nil {
				log.Fatal(err)
			}
		}
		commit(args)
	}
}

func commit(args *CommitArgs) {
	replys := CommitReply{}

	call("Master.Commit", &args, &replys)
}

func mapping(mapf func(string, string) []KeyValue, filename string, nReduce, index int) error {
	file, err := os.Open(filename)
	if err != nil {
		return fmt.Errorf("cannot open %v", filename)
	}
	content, err := ioutil.ReadAll(file)
	if err != nil {
		return fmt.Errorf("cannot read %v", filename)
	}
	file.Close()
	kva := mapf(filename, string(content))

	sort.Sort(ByKey(kva))

	var fileBucket = make(map[int]*json.Encoder)
	for i := 0; i < nReduce; i++ {
		oname := fmt.Sprintf("mr-%d-%d", index, i)
		ofile, _ := os.Create(oname)

		fileBucket[i] = json.NewEncoder(ofile)
		defer ofile.Close()
	}

	for _, v := range kva {
		reduceID := ihash(v.Key) % nReduce

		// å†™å…¥æ–‡ä»¶ mr-X-Y ä¸­
		enc := fileBucket[reduceID]
		err := enc.Encode(&v)
		if err != nil {
			return err
		}
	}

	return nil
}

// GetMapTask ...
func GetMapTask() (bool, *AssignReply) {
	args := AssignArgs{}

	replys := AssignReply{}

	if !call("Master.Assign", &args, &replys) {
		return false, nil
	}

	return true, &replys
}

func reducing(reducef func(string, []string) string, nReduce, index int) error {

	kva := make([]KeyValue, 0)
	for i := 0; i < nReduce; i++ {
		filename := fmt.Sprintf("mr-%d-%d", i, index)

		file, _ := os.Open(filename)

		dec := json.NewDecoder(file)
		for {
			var kv KeyValue
			if err := dec.Decode(&kv); err != nil {
				break
			}
			kva = append(kva, kv)
		}
	}

	sort.Sort(ByKey(kva))

	outFilename := fmt.Sprintf("mr-out-%d", index)
	ofile, _ := os.Create(outFilename)

	i := 0
	for i < len(kva) {
		j := i + 1
		for j < len(kva) && kva[j].Key == kva[i].Key {
			j++
		}
		values := []string{}
		for k := i; k < j; k++ {
			values = append(values, kva[k].Value)
		}
		output := reducef(kva[i].Key, values)

		// this is the correct format for each line of Reduce output.
		fmt.Fprintf(ofile, "%v %v\n", kva[i].Key, output)

		i = j
	}

	return nil
}

```

### Makefile
```Makefile
master:
	go run mrmaster.go pg-*.txt

partial:
	go run mrmaster.go pg-being_ernest.txt

build:
	go build -buildmode=plugin ../mrapps/wc.go

worker:
	go build -buildmode=plugin ../mrapps/wc.go
	go run mrworker.go wc.so

reset:
	rm -rf mr-*
	rm mrmaster
	rm mrworker
	rm mrsequential

test:
	sh test-mr.sh
```

ä»£ç å‚è€ƒäº†[Lab 1 è§£å†³æ–¹æ¡ˆè®°å½•](https://www.yuque.com/abser/blog/lab1mapreduce#llnIF)ï¼Œåœ¨æ­¤è¡¨ç¤ºæ„Ÿè°¢ã€‚

## æµ‹è¯•ç”¨ä¾‹

è¿è¡Œ `sh test-mr.sh` / `make test`æ¥æŸ¥çœ‹æ˜¯å¦é€šè¿‡äº†çš„æµ‹è¯•ç”¨ä¾‹ã€‚

æ³¨ï¼šmacosä¸­æ²¡æœ‰`timeout`å‘½ä»¤ï¼Œè¿è¡Œæµ‹è¯•è„šæœ¬çš„æ—¶å€™ä¼šå‡ºé”™ï¼Œè§£å†³æ–¹æ¡ˆå¯ä»¥å‚è€ƒ[Timeout command on Mac OS X? - Stack Overflow](https://stackoverflow.com/questions/3504945/timeout-command-on-mac-os-x)ã€‚

```shell
*** Starting wc test.
2020/08/19 22:04:41 rpc.Register: method "Done" has 1 input parameters; needs exactly three
--- wc test: PASS
*** Starting indexer test.
2020/08/19 22:04:48 rpc.Register: method "Done" has 1 input parameters; needs exactly three
--- indexer test: PASS
*** Starting map parallelism test.
2020/08/19 22:04:51 rpc.Register: method "Done" has 1 input parameters; needs exactly three
--- map parallelism test: PASS
*** Starting reduce parallelism test.
2020/08/19 22:04:58 rpc.Register: method "Done" has 1 input parameters; needs exactly three
--- reduce parallelism test: PASS
*** Starting crash test.
2020/08/19 22:05:06 rpc.Register: method "Done" has 1 input parameters; needs exactly three
2020/08/19 22:05:17 ../pg-being_ernest.txt map task timeout
--- crash test: PASS
*** PASSED ALL TESTS
```

å½“æˆ‘çœ‹åˆ°æ»¡å±çš„ `PASSED` å’Œæœ€åçš„ `PASSED ALL TESTS`ï¼ŒæŠŠğŸ‘´é«˜å…´åäº†ã€‚
